<!DOCTYPE html>
	<head>
		<meta charset="utf-8">
		<style>

			body {
			  /*font-family: 'Stalemate', cursive;*/
			  font-family: 'Macondo Swash Caps', cursive;
			  font-size: 12px;
			}

			.group-tick line {
			  stroke: #000;
			}

			.ribbons {
			  fill-opacity: 0.67;
			}
			
			.inner-label {
				font-size: 14px;
				fill: #232323;
			}
			
			.outer-label {
				font-size: 14px;
				fill: #5f5f5f;
			}

		</style>
		
		<!-- Google fonts -->
		<link href="https://fonts.googleapis.com/css?family=Macondo+Swash+Caps" rel="stylesheet">
		
		<!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->
		<script src="../../../plugins/d3.js"></script>
		<script src="../../../plugins/underscore.js"></script>
		
	</head>
	<body>
		<div id="chart"></div>
		
		<script>

			var margin = {left:90, top:90, right:90, bottom:90},
				width = Math.min(window.innerWidth, 900) - margin.left - margin.right,
			    height = Math.min(window.innerWidth, 900) - margin.top - margin.bottom,
			    innerRadius = Math.min(width, height) * .45,
			    outerRadius = innerRadius * 1.05;
	
			////////////////////////////////////////////////////////////
			////////////////// Set-up Chord parameters /////////////////
			////////////////////////////////////////////////////////////
									
			var chord = chordNB()
			    .padAngle(0.05)
				.sortSubgroups(sortAlpha)
				.heightInner(28)
				.widthOffsetInner(30)
				//.widthOffsetInner(function(d) { return 6 * d.length; })
				.value(function(d) { return d.words; })
				.inner(function(d) { return d.character; })
				.outer(function(d) { return d.location; });
			
			var arc = d3.arc()
			    .innerRadius(innerRadius*1.01)
			    .outerRadius(outerRadius);

			var ribbon = ribbonNB()
			    .radius(innerRadius);

			//var formatValue = d3.formatPrefix(",.0", 1e2);
	
			////////////////////////////////////////////////////////////
			////////////////////// Create SVG //////////////////////////
			////////////////////////////////////////////////////////////
						
			var svg = d3.select("#chart").append("svg")
			    .attr("width", width + margin.left + margin.right)
			    .attr("height", height + margin.top + margin.bottom);
			
			var fellowship = ["Frodo","Sam","Pippin","Merry","Gandalf","Aragorn","Boromir","Legolas","Gimli"];
			var dataset;
			d3.csv('../../data/nadieh/lotr_words_locations.csv', function (error, data) {
				
				data.forEach(function(d) {
					d.words = +d.words;
				});
				
				//Only keep the members of the fellowship & remove Voiceover
				dataset = data.filter(function(d) { 
					return _.contains(fellowship, d.character) && d.location !== "Voiceover"; 
				});	
				
				//Aggregate the data by detailed location
				var dataAgg = dataGrouper.sum(dataset, ["location","character"]);
	
				//Get the unique locations
				//var locations = _.uniq(_.pluck(dataAgg, "location"));
				var locations = ["Bree Land", "Emyn Muil", "Fangorn", "Gondor", "Isengard", "Lothlorien", "Misty Mountains", "Mordor", "Moria", "Parth Galen", "Rivendell", "Rohan", "The Shire"];
				var colors = ["#684F53", "#6B8884", "#324E25", "#C6CAC9", "#213C47", "#628833", "#DDDED9", "#730b0b", "#8a290d", "#306E3F", "#8D9413", "#C99E54", "#3C7E16"];
				var color = d3.scaleOrdinal()
			    	.domain(locations)
			    	.range(colors);
				
				
				var g = svg.append("g")
				    .attr("transform", "translate(" + (width/2 + margin.left) + "," + (height/2 + margin.top) + ")")
				    //.datum(chord(dataNested));
					.datum(chord(dataAgg));
							
	
				////////////////////////////////////////////////////////////
				////////////////////// Draw outer Arcs /////////////////////
				////////////////////////////////////////////////////////////

				var arcs = g.append("g")
				    .attr("class", "arcs")
				  .selectAll("g")
				    .data(function(chords) { 
						return chords.groups; 
					})
				  .enter().append("g");

				var outerArcs = arcs.append("path")
				    .style("fill", function(d) { return color(d.outername); })
				    .attr("d", arc)
				  	.on("mouseover", function(d) { console.log(d); });
					
				////////////////////////////////////////////////////////////
				//////////////////// Draw outer Labels /////////////////////
				////////////////////////////////////////////////////////////
								  
				var outerLabels = g.append("g")
				  .attr("class", "outer-labels");
				  
				outerArcs
				  .each(function(d,i) {
				  		//Search pattern for everything between the start and the first capital L
				  		var firstArcSection = /(^.+?)L/; 	

				  		//Grab everything up to the first Line statement
				  		var newArc = firstArcSection.exec( d3.select(this).attr("d") )[1];
				  		//Replace all the comma's so that IE can handle it
				  		newArc = newArc.replace(/,/g , " ");
		
				  		//If the end angle lies beyond a quarter of a circle (90 degrees or pi/2) 
				  		//flip the end and start position
				  		if (d.endAngle > 90*Math.PI/180 & d.startAngle < 270*Math.PI/180) {
				  			var startLoc 	= /M(.*?)A/,		//Everything between the first capital M and first capital A
				  				middleLoc 	= /A(.*?)0 0 1/,	//Everything between the first capital A and 0 0 1
				  				endLoc 		= /0 0 1 (.*?)$/;	//Everything between the first 0 0 1 and the end of the string (denoted by $)
				  			//Flip the direction of the arc by switching the start en end point (and sweep flag)
				  			//of those elements that are below the horizontal line
				  			var newStart = endLoc.exec( newArc )[1];
				  			var newEnd = startLoc.exec( newArc )[1];
				  			var middleSec = middleLoc.exec( newArc )[1];
			
				  			//Build up the new arc notation, set the sweep-flag to 0
				  			newArc = "M" + newStart + "A" + middleSec + "0 0 0 " + newEnd;
				  		}//if
		
				  		//Create a new invisible arc that the text can flow along
				  		outerLabels.append("path")
				  			.attr("class", "hiddenArcs")
				  			.attr("id", "arc"+i)
				  			.attr("d", newArc)
				  			.style("fill", "none");
				  	});

				//Append the label names on the outside
				arcs.append("text")
					.attr("class", "outer-label")
					.attr("dy", function(d,i) { return (d.endAngle > 90*Math.PI/180 & d.startAngle < 270*Math.PI/180 ? 25 : -16); })
				   .append("textPath")
					.attr("startOffset","50%")
					.style("text-anchor","middle")
					.attr("xlink:href",function(d,i){return "#arc"+i;})
					.text(function(d,i){ return d.outername; });

				////////////////////////////////////////////////////////////
				////////////////// Draw inner ribbons ///////////////////////
				////////////////////////////////////////////////////////////
				
				var ribbons = g.append("g")
				    .attr("class", "ribbons")
				  .selectAll("path")
				    .data(function(chords) { 
						return chords; 
					})
				  .enter().append("path")
				    .attr("d", ribbon)
				    .style("fill", function(d) { return color(d.outer.outername); })
					.on("mouseover", function(d) { console.log(d); });
					
				////////////////////////////////////////////////////////////
				//////////////////// Draw inner labels /////////////////////
				////////////////////////////////////////////////////////////
						
				//The text also needs to be displaced in the horizontal directions
				//And also rotated with the offset in the clockwise direction
				var innerLabels = g.append("g")
					.attr("class","inner-labels")
				  .selectAll("text")
				    .data(function(chords) { 
						return chords.innergroups; 
					})
				  .enter().append("text")
					.attr("class", "inner-label")
					.attr("x", function(d,i) { return d.x; })
					.attr("y", function(d,i) { return d.y; })
					.style("text-anchor", "middle")
					.attr("dy", ".35em")
				    .text(function(d,i) { return d.name; });
				  		
			});//d3.csv
							
			////////////////////////////////////////////////////////////
			///////////////////// New ribbon function //////////////////
			////////////////////////////////////////////////////////////

		    var slice$5 = Array.prototype.slice;
	
		    function ribbonNB() {
				
  			  var cos = Math.cos;
  			  var sin = Math.sin;
  			  var pi$3 = Math.PI;
  			  var halfPi$2 = pi$3 / 2;
  			  var tau$3 = pi$3 * 2;
  			  var max$1 = Math.max;
			  
		      var inner = function (d) { return d.inner; },
		          outer = function (d) { return d.outer; },
		          radius = function (d) { return d.radius; },
		          startAngle = function (d) { return d.startAngle; },
		          endAngle = function (d) { return d.endAngle; },
			  	  x = function (d) { return d.x; },
			  	  y = function (d) { return d.y; },
			  	  offset = function (d) { return d.offset; },
		          context = null;

		      function ribbon() {
		        var buffer,
		            argv = slice$5.call(arguments),
		            out = outer.apply(this, argv),
		            inn = inner.apply(this, argv),
		            sr = +radius.apply(this, (argv[0] = out, argv)),
		            sa0 = startAngle.apply(this, argv) - halfPi$2,
		            sa1 = endAngle.apply(this, argv) - halfPi$2,
		            sx0 = sr * cos(sa0),
		            sy0 = sr * sin(sa0),
		            sx1 = sr * cos(sa1),
		            sy1 = sr * sin(sa1),
		            tr = +radius.apply(this, (argv[0] = inn, argv)),
				  	tx = x.apply(this, argv),
				  	ty = y.apply(this, argv),
				  	toffset = offset.apply(this, argv),
				  	xco,
				    yco,
				  	xci,
				    yci,
				  	leftHalf;
					
					//Does the group lie on the left side
					leftHalf = sa0+halfPi$2 > pi$3 && sa0+halfPi$2 < tau$3;
					//If the group lies on the other side, switch the inner point offset
					if(leftHalf) toffset = -toffset;
					tx = tx + toffset;
					
			        if (!context) context = buffer = d3.path();
					
					//Start at smallest angle of outer arc
			        context.moveTo(sx0, sy0);
					//Circular part along the outer arc
			        context.arc(0, 0, sr, sa0, sa1);
					//From end outer arc to center
		            xco = d3.interpolateNumber(0, sx1)(0.5);
		            yco = d3.interpolateNumber(0, sy1)(0.5);
					if( (!leftHalf && sx1 < tx) || (leftHalf && sx1 > tx) ) {
						xci = tx + (tx - sx1)/2;//d3.interpolateNumber(tx, sx1)(0.5);
						yci = d3.interpolateNumber(ty, sy1)(0.5);
					} else {
						xci = d3.interpolateNumber(tx, sx1)(0.5);
						yci = ty;
					}//else
			        context.bezierCurveTo(xco, yco, xci, yci, tx, ty);
					//From center to start of outer arc
		            xco = d3.interpolateNumber(0, sx0)(0.5);
		            yco = d3.interpolateNumber(0, sy0)(0.5);
					if( (!leftHalf && sx0 < tx) || (leftHalf && sx0 > tx) ) { 
						xci = tx + (tx - sx0)/2;//d3.interpolateNumber(tx, sx1)(0.5);
						yci = d3.interpolateNumber(ty, sy0)(0.5);
					} else {
						xci = d3.interpolateNumber(tx, sx0)(0.5);
						yci = ty;
					}//else
					context.bezierCurveTo(xci, yci, xco, yco, sx0, sy0);
					//Close path
					context.closePath();

			        if (buffer) return context = null, buffer + "" || null;
		      }//function ribbon

	  		  function constant$11(x) {
	  		      return function() { return x; };
	  		  }//constant$11
			
		      ribbon.radius = function(_) {
		        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$11(+_), ribbon) : radius;
		      };

		      ribbon.startAngle = function(_) {
		        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$11(+_), ribbon) : startAngle;
		      };

		      ribbon.endAngle = function(_) {
		        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$11(+_), ribbon) : endAngle;
		      };
			  
		      ribbon.x = function(_) {
		        return arguments.length ? (x = _, ribbon) : x;
		      };

		      ribbon.y = function(_) {
		        return arguments.length ? (y = _, ribbon) : y;
		      };

		      ribbon.offset = function(_) {
		        return arguments.length ? (offset = _, ribbon) : offset;
		      };

		      ribbon.inner = function(_) {
		        return arguments.length ? (inner = _, ribbon) : inner;
		      };

		      ribbon.outer = function(_) {
		        return arguments.length ? (outer = _, ribbon) : outer;
		      };

		      ribbon.context = function(_) {
		        return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
		      };

		      return ribbon;
		    }
			
			////////////////////////////////////////////////////////////
			///////////////////// New chord function ///////////////////
			////////////////////////////////////////////////////////////
				
		    function chordNB() {
				
			  var pi$3 = Math.PI;
			  var tau$3 = pi$3 * 2;
			  var max$1 = Math.max;
				
		      var padAngle = 0,
		          sortGroups = null,
		          sortSubgroups = null,
			  	  sortChords = null,
			  	  heightInner = 20,
			  	  widthOffsetInner = function() { return x; },
			  	  value = function(d) { return d; },
				  inner = function(d) { return d.source; },
			  	  outer = function(d) { return d.target; };

		      function chord(data) {
				  
				  //Nest the data on the outer variable
				  data = d3.nest().key(outer).entries(data);
				  
				  var n = data.length,
				  	groupSums = [],
		            groupIndex = d3.range(n),
		            subgroupIndex = [],
		            chords = [],
		            groups = chords.groups = new Array(n),
		            subgroups,
					numSubGroups,
				  	uniqueInner = chords.innergroups = [],
				  	uniqueCheck = [],
		            k,
		            x,
		            x0,
		            dx,
		            i,
		            j,
				  	m,
				  	s,
				    v,
				    sum,
				  	counter,
					reverseOrder = false;

				//Loop over the outer groups and sum the values
				k = 0;
				numSubGroups = 0;
				for(i = 0; i < n; i++) {
					v = data[i].values.length;
					sum = 0;
					for(j = 0; j < v; j++) {
						sum += value(data[i].values[j]);
					}//for j
					groupSums.push(sum);
					subgroupIndex.push(d3.range(v));
					numSubGroups += v;
					k += sum;	
				}//for i
				
		        // Sort groups…
		        if (sortGroups) groupIndex.sort(function(a, b) {
		          return sortGroups(groupSums[a], groupSums[b]);
		        });

		        // Sort subgroups…
		        if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
		          d.sort(function(a, b) {
		            return sortSubgroups( inner(data[i].values[a]), inner(data[i].values[b]) );
		          });
		        });
			  
		        // Convert the sum to scaling factor for [0, 2pi].
		        k = max$1(0, tau$3 - padAngle * n) / k;
		        dx = k ? padAngle : tau$3 / n;
			  
		        // Compute the start and end angle for each group and subgroup.
		        // Note: Opera has a bug reordering object literal properties!
				subgroups = new Array(numSubGroups);
		        x = 0;
				counter = 0;
				for(i = 0; i < n; i++) {
					var di = groupIndex[i],
						outername = data[di].key;
					
					x0 = x;
					//If you've crossed the bottom, reverse the order of the inner ribbons
					if(x > pi$3) reverseOrder = true;
					s = subgroupIndex[di].length;
					for(j = 0; j < s; j++) {
			            var dj = reverseOrder ? subgroupIndex[di][(s-1)-j] : subgroupIndex[di][j],
			                v = value(data[di].values[dj]),
							innername = inner(data[di].values[dj]);
			                a0 = x,
			                a1 = x += v * k;
				        subgroups[counter] = {
				              index: di,
				              subindex: dj,
				              startAngle: a0,
				              endAngle: a1,
				              value: v,
							  outername: outername,
							  innername: innername
				        };
						
						//Check and save the unique inner names
					    if( !uniqueCheck[innername] ) {
					    	uniqueCheck[innername] = true;
					    	uniqueInner.push({name: innername});
						}//if
						
						counter += 1;
					}//for j
	  		        groups[di] = {
	  		            index: di,
	  		            startAngle: x0,
	  		            endAngle: x,
	  		            value: groupSums[di],
						outername: outername
	  		        };
	  		        x += dx;		
				}//for i

				//Sort the inner groups in the same way as the ribbons
	          	uniqueInner.sort(function(a, b) {
	            	return sortSubgroups( a.name, b.name );
	          	});
				//Find x and y locations of the inner categories
				//TODO: make x depend on length of inner name	
				m = uniqueInner.length
				for(i = 0; i < m; i++) {
					uniqueInner[i].x = 0;
					uniqueInner[i].y = -m*heightInner/2 + i*heightInner;
					uniqueInner[i].offset = widthOffsetInner(uniqueInner[i].name, i, uniqueInner);
				}//for i
	          			
  		        //Generate chords for each (non-empty) subgroup-subgroup link
				counter = 0;
				for(i = 0; i < n; i++) {
					var di = groupIndex[i];
					s = subgroupIndex[di].length;
					for(j = 0; j < s; j++) {
						var outerGroup = subgroups[counter];
						var innerTerm = outerGroup.innername;
						//Find the correct inner object based on the name
						var innerGroup = searchTerm(innerTerm, "name", uniqueInner);
		  		            if (outerGroup.value) {
		  		              chords.push({inner: innerGroup, outer: outerGroup});
		  		            }//if
						counter +=1;
					}//for j
				}//for i

		        return sortChords ? chords.sort(sortChords) : chords;
		      };//function chord(matrix)

	  		  function constant$11(x) {
	  		      return function() { return x; };
	  		  }//constant$11
			  
		      chord.padAngle = function(_) {
		        return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
		      };

		      chord.inner = function(_) {
		        return arguments.length ? (inner = _, chord) : inner;
		      };
			  
		      chord.outer = function(_) {
		        return arguments.length ? (outer = _, chord) : outer;
		      };
			  
		      chord.value = function(_) {
		        return arguments.length ? (value = _, chord) : value;
		      };
			  
		      chord.heightInner = function(_) {
		        return arguments.length ? (heightInner = _, chord) : heightInner;
		      };
	
		      chord.widthOffsetInner = function(_) {
		        return arguments.length ? (widthOffsetInner = typeof _ === "function" ? _ : constant$11(+_), chord) : widthOffsetInner;
		      };
			  
		      chord.sortGroups = function(_) {
		        return arguments.length ? (sortGroups = _, chord) : sortGroups;
		      };

		      chord.sortSubgroups = function(_) {
		        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
		      };

		      chord.sortChords = function(_) {
		        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
		      };

		      return chord;
		    }//chordNB
			
			function searchTerm(term, property, arrayToSearch){
			    for (var i=0; i < arrayToSearch.length; i++) {
			        if (arrayToSearch[i][property] === term) {
			            return arrayToSearch[i];
			        }//if
			    }//for i
			}//searchTerm

			////////////////////////////////////////////////////////////
			////////////////// Extra Functions /////////////////////////
			////////////////////////////////////////////////////////////

			//Sort alphabetically
			function sortAlpha(a, b){
				    if(a < b) return -1;
				    if(a > b) return 1;
				    return 0;
			}//sortAlpha
							
			// // Returns an array of tick angles and values for a given group and step.
			// function groupTicks(d, step) {
			//   var k = (d.endAngle - d.startAngle) / d.value;
			//   return d3.range(0, d.value, step).map(function(value) {
			//     return {value: value, angle: value * k + d.startAngle};
			//   });
			// }//groupTicks
	
			//http://stackoverflow.com/questions/14446511/what-is-the-most-efficient-method-to-groupby-on-a-javascript-array-of-objects
			var dataGrouper = (function() {
			    var has = function(obj, target) {
			        return _.any(obj, function(value) {
			            return _.isEqual(value, target);
			        });
			    };

			    var keys = function(data, names) {
			        return _.reduce(data, function(memo, item) {
			            var key = _.pick(item, names);
			            if (!has(memo, key)) {
			                memo.push(key);
			            }
			            return memo;
			        }, []);
			    };

			    var group = function(data, names) {
			        var stems = keys(data, names);
			        return _.map(stems, function(stem) {
			            return {
			                key: stem,
			                vals:_.map(_.where(data, stem), function(item) {
			                    return _.omit(item, names);
			                })
			            };
			        });
			    };

			    group.register = function(name, converter) {
			        return group[name] = function(data, names) {
			            return _.map(group(data, names), converter);
			        };
			    };

			    return group;
			}());

			dataGrouper.register("sum", function(item) {
			    return _.extend({}, item.key, {
					words: _.reduce(item.vals, function(memo, node) {
			        	return memo + node.words;
			    	}, 0)
				});
			});
				
				
		</script>
	</body>
</html>