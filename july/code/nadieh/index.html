<!DOCTYPE html>
	<head>
		<meta charset="utf-8">
		<style>
			html { font-size: 62.5%; } 
			
			body {
			  font-family: 'Open Sans', sans-serif;
			  font-size: 10px;
			  fill: #b9b9b9;
			}
			
			.group-tick {
				
				font-size: 8px;
				font-weight: 300;
				fill: #b9b9b9;
			}

			.group-tick line {
			    stroke: #909090;
			    stroke-width: 0.5px;
			}

			.string {
/*			  	opacity: 0.7;*/
			}

			.upper-title {
				text-anchor: middle;
				font-size: 1.2rem;
			}
			
			.name-title {
				font-family: 'Macondo Swash Caps', cursive;
				font-size: 2.8rem;
				fill: #232323;
				cursor: default;
				text-anchor: middle;
			}
			
			.value-title {
				font-family: 'Macondo Swash Caps', cursive;
				text-anchor: middle;
				font-size: 1.8rem;
			}
						
			.inner-label {
				font-family: 'Macondo Swash Caps', cursive;
				font-size: 1.4rem;
				fill: #232323;
				cursor: default;
			}
			
			.outer-label {
				font-family: 'Macondo Swash Caps', cursive;
				font-size: 14px;
				fill: #5f5f5f;
				cursor: default;
			}

		</style>
		
		<!-- Google fonts -->
		<link href="https://fonts.googleapis.com/css?family=Macondo+Swash+Caps" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
		
		<!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->
		<script src="../../../plugins/d3.js"></script>
		<script src="../../../plugins/underscore.js"></script>
		
		<!-- Custom "chord" and "ribbon" functions -->
		<script src="loom.js"></script>
		<script src="string.js"></script>
		
	</head>
	<body>
		<div id="chart"></div>
		
		<script>

			var margin = {left:200, top:40, right:200, bottom:50},
				width = Math.max( Math.min(window.innerWidth, 1100) - margin.left - margin.right - 20, 300),
			    height = Math.max( Math.min(window.innerHeight, 900) - margin.top - margin.bottom - 20, 300),
			    innerRadius = Math.min(width, height) * .45,
			    outerRadius = innerRadius * 1.05;
				
			//Reset the overall font size
			var newFontSize = Math.max(40, innerRadius * 62.5 / 250);
			d3.select("html").style("font-size", newFontSize + "%");
	
			////////////////////////////////////////////////////////////
			////////////////// Set-up Chord parameters /////////////////
			////////////////////////////////////////////////////////////
				
			var pullOutSize = 20 + 30/135 * innerRadius;
			var numFormat = d3.format(",.0f");
									
			var loom = loom()
			    .padAngle(0.05)
				//.sortSubgroups(sortAlpha)
				//.heightInner(28)
				.emptyPerc(0.2)
				.widthOffsetInner(30)
				//.widthOffsetInner(function(d) { return 6 * d.length; })
				.value(function(d) { return d.words; })
				.inner(function(d) { return d.character; })
				.outer(function(d) { return d.location; });
			
			var arc = d3.arc()
			    .innerRadius(innerRadius*1.01)
			    .outerRadius(outerRadius);

			var string = string()
			    .radius(innerRadius)
				.pullout(pullOutSize);

			//var formatValue = d3.formatPrefix(",.0", 1e2);
	
			////////////////////////////////////////////////////////////
			////////////////////// Create SVG //////////////////////////
			////////////////////////////////////////////////////////////
						
			var svg = d3.select("#chart").append("svg")
			    .attr("width", width + margin.left + margin.right)
			    .attr("height", height + margin.top + margin.bottom);

			////////////////////////////////////////////////////////////
			///////////////////// Read in data /////////////////////////
			////////////////////////////////////////////////////////////
						
			d3.csv('../../data/nadieh/lotr_words_locations.csv', function (error, data) {
	
				////////////////////////////////////////////////////////////
				///////////////////// Prepare the data /////////////////////
				////////////////////////////////////////////////////////////
							
				data.forEach(function(d) {
					d.words = +d.words;
				});
				
				//Only keep the members of the fellowship & remove Voiceover
				var fellowship = ["Frodo","Sam","Pippin","Merry","Gandalf","Aragorn","Boromir","Legolas","Gimli"];
				data = data.filter(function(d) { 
					return fellowship.indexOf(d.character) > -1 && d.location !== "Voiceover"; 
				});	
				
				//Aggregate the data by detailed location
				var dataAgg = dataGrouper.sum(data, ["location","character"]);
				dataAgg.sort(sortLocation);
				
				//Sort the inner characters based on the total number of words spoken
				
				//Find the total number of words per character
				var dataChar = d3.nest()
					.key(function(d) { return d.character; })
					.rollup(function(leaves) { return d3.sum(leaves, function(d) { return d.words; }); })
					.entries(dataAgg)
					.sort(function(a, b){ return d3.descending(a.value, b.value); });				
				//Unflatten the result
				var characterOrder = dataChar.map(function(d) { return d.key; });
				//Sort the characters on a specific order
				function sortCharacter(a, b) {
				  	return characterOrder.indexOf(a) - characterOrder.indexOf(b);
				}//sortCharacter
				
				
				loom
					.sortSubgroups(sortCharacter)
					.heightInner(innerRadius*0.75/characterOrder.length);
				
				////////////////////////////////////////////////////////////
				///////////////////////// Colors ///////////////////////////
				////////////////////////////////////////////////////////////
								
				//Color for the unique locations
				var locations = ["Bree", "Emyn Muil", "Fangorn", "Gondor", "Isengard", "Lothlorien", "Misty Mountains", "Mordor", "Moria", "Parth Galen", "Rivendell", "Rohan", "The Shire"];
				var colors = ["#684F53", "#6B8884", "#324E25", "#C6CAC9", "#213C47", "#628833", "#DDDED9", "#730b0b", "#8a290d", "#306E3F", "#8D9413", "#C99E54", "#3C7E16"];
				var color = d3.scaleOrdinal()
			    	.domain(locations)
			    	.range(colors);
				
				//Create a group that already holds the data
				var g = svg.append("g")
				    .attr("transform", "translate(" + (width/2 + margin.left) + "," + (height/2 + margin.top) + ")")
					.datum(loom(dataAgg));	
	

				////////////////////////////////////////////////////////////
				///////////////////// Set-up title /////////////////////////
				////////////////////////////////////////////////////////////
			
				var titles = g.append("g")
					.attr("class", "texts")
					.style("opacity", 0);
				
				// titles.append("text")
				// 	.attr("class", "upper-title")
				// 	.attr("x", 0)
				// 	.attr("y", -height/2 + 10)
				// 	.text("total number of words spoken by");
					
				titles.append("text")
					.attr("class", "name-title")
					.attr("x", 0)
					.attr("y", -height/2 + 50);
					
				titles.append("text")
					.attr("class", "value-title")
					.attr("x", 0)
					.attr("y", -height/2 + 75);
								
				////////////////////////////////////////////////////////////
				////////////////////// Draw outer arcs /////////////////////
				////////////////////////////////////////////////////////////

				var arcs = g.append("g")
				    .attr("class", "arcs")
				  .selectAll("g")
				    .data(function(s) { 
						return s.groups; 
					})
				  .enter().append("g")
				  	.each(function(d) { 
						d.pullOutSize = (pullOutSize * ( d.startAngle > Math.PI + 1e-2 ? -1 : 1)) 
					})
			 	 	.on("mouseover", function(d) {
					    d3.selectAll(".string")
					      	.transition()
					        .style("opacity", function(s) { return s.outer.outername === d.outername ? 0.9 : 0.05; });
			 	 	})
			     	.on("mouseout", function(d) {
					    d3.selectAll(".string")
					      	.transition()
					        .style("opacity", 0.7);
			 	 	});

				var outerArcs = arcs.append("path")
					.attr("class", "arc")
				    .style("fill", function(d) { return color(d.outername); })
				    .attr("d", arc)
					.attr("transform", function(d, i) { //Pull the two slices apart
					  	return "translate(" + d.pullOutSize + ',' + 0 + ")";
					 });

				////////////////////////////////////////////////////////////
				///////////////////// Draw group ticks /////////////////////
				////////////////////////////////////////////////////////////
					 
				 // //Not really an added valye here, so no tick marks
				 // var groupTick = arcs.selectAll(".group-tick")
				 //     .data(function(d) { return groupTicks(d, 5e2); })
				 //   .enter().append("g")
				 //     .attr("class", "group-tick")
				 //     .attr("transform", function(d) { return "translate(" + d.pullOutSize + ',' + 0 + ")rotate(" + (d.angle * 180 / Math.PI - 90) + ") translate(" + outerRadius + ",0)"; });
				 //
				 // groupTick.append("line")
				 //     .attr("x2", 6);
				 //
				 // groupTick
				 //   .filter(function(d) { return d.value % 5e2 === 0; })
				 //   .append("text")
				 //     .attr("x", 8)
				 //     .attr("dy", ".35em")
				 //     .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180) translate(-16)" : null; })
				 //     .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
				 //     .text(function(d) { return d.value; });
					 					
				////////////////////////////////////////////////////////////
				//////////////////// Draw outer labels /////////////////////
				////////////////////////////////////////////////////////////

				//The text needs to be rotated with the offset in the clockwise direction
				var outerLabels = arcs.append("g")
					.each(function(d) { d.angle = ((d.startAngle + d.endAngle) / 2); })
					.attr("class", "outer-labels")
					.attr("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
					.attr("transform", function(d,i) { 
						var c = arc.centroid(d);
						return "translate(" + (c[0] + d.pullOutSize) + "," + c[1] + ")"
						+ "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
						+ "translate(" + 26 + ",0)"
						+ (d.angle > Math.PI ? "rotate(180)" : "")
					})
					
				//The outer name
				outerLabels.append("text")
					.attr("class", "outer-label")
					.attr("dy", ".35em")
					.text(function(d,i){ return d.outername; });
					
				//The value below it
				outerLabels.append("text")
					.attr("class", "outer-label-value")
					.attr("dy", "2em")
					.text(function(d,i){ return numFormat(d.value) + " words"; });

				////////////////////////////////////////////////////////////
				////////////////// Draw inner strings //////////////////////
				////////////////////////////////////////////////////////////
				
				var strings = g.append("g")
				    .attr("class", "stringWrapper")
				  .selectAll("path")
				    .data(function(strings) { 
						return strings; 
					})
				  .enter().append("path")
					.attr("class", "string")
				    .attr("d", string)
				    .style("fill", function(d) { return color(d.outer.outername); })
					.style("opacity", 0.7);
					
				////////////////////////////////////////////////////////////
				//////////////////// Draw inner labels /////////////////////
				////////////////////////////////////////////////////////////
						
				//The text also needs to be displaced in the horizontal directions
				//And also rotated with the offset in the clockwise direction
				var innerLabels = g.append("g")
					.attr("class","inner-labels")
				  .selectAll("text")
				    .data(function(s) { 
						return s.innergroups; 
					})
				  .enter().append("text")
					.attr("class", "inner-label")
					.attr("x", function(d,i) { return d.x; })
					.attr("y", function(d,i) { return d.y; })
					.style("text-anchor", "middle")
					.attr("dy", ".35em")
				    .text(function(d,i) { return d.name; })
			 	 	.on("mouseover", function(d) {
						
						//Show all the strings of the highlighted character and hide all else
					    d3.selectAll(".string")
					      	.transition()
					        .style("opacity", function(s) {
								return s.outer.innername !== d.name ? 0.02 : 0.9;
							});
							
						//Update the word count of the outer labels
						var characterData = loom(dataAgg).filter(function(s) { return s.outer.innername === d.name; });
						d3.selectAll(".outer-label-value")
							.text(function(s,i){
								//Find which characterData is the correct one based on location
								var loc = characterData.filter(function(c) { return c.outer.outername === s.outername; });
								if(loc.length === 0) {
									var value = 0;
								} else {
									var value = loc[0].outer.value;
								}
								return numFormat(value) + (value === 1 ? " word" : " words"); 
								
							});
						
						//Hide the arc where the character hasn't said a thing
						d3.selectAll(".arc")
					      	.transition()
					        .style("opacity", function(s) {
								//Find which characterData is the correct one based on location
								var loc = characterData.filter(function(c) { return c.outer.outername === s.outername; });
								return loc.length === 0 ? 0.02 : 1;
							});
								
						//Update the title to show the total word count of the character
						d3.selectAll(".texts")
							.transition()
							.style("opacity", 1);	
						d3.select(".name-title")
							.text(d.name);
						d3.select(".value-title")
							.text(function() {
								var words = dataChar.filter(function(s) { return s.key === d.name; });
								return numFormat(words[0].value);
							});
							
					})
			     	.on("mouseout", function(d) {
						
						//Put the string opacity back to normal
					    d3.selectAll(".string")
					      	.transition()
							.style("opacity", 0.7);
							
						//Return the word count to what it was
						d3.selectAll(".outer-label-value")	
							.text(function(s,i){ return numFormat(s.value) + " words"; });
							
						//Show all arcs again
						d3.selectAll(".arc")
					      	.transition()
					        .style("opacity", 1);
						
						//Hide the title
						d3.selectAll(".texts")
							.transition()
							.style("opacity", 0);
					});
				  		
			});//d3.csv

			////////////////////////////////////////////////////////////
			///////////////////// Extra functions //////////////////////
			////////////////////////////////////////////////////////////

			//Sort the locations in a particula order
			function sortLocation(a, b) {
				var locationOrder = ["The Shire", "Bree", "Isengard", "Rivendell", "Misty Mountains", "Moria", "Lothlorien", "Parth Galen", "Emyn Muil", "Rohan", "Fangorn", "Gondor", "Mordor"];
			  	return locationOrder.indexOf(a.location) - locationOrder.indexOf(b.location);
			}//sortLocation
			
			//Sort alphabetically
			function sortAlpha(a, b){
				    if(a < b) return -1;
				    if(a > b) return 1;
				    return 0;
			}//sortAlpha
			
			//Sort on the number of words
			function sortWords(a, b){
				    if(a.words < b.words) return -1;
				    if(a.words > b.words) return 1;
				    return 0;
			}//sortWords
							
			// // Returns an array of tick angles and values for a given group and step.
			// function groupTicks(d, step) {
			//   var k = (d.endAngle - d.startAngle) / d.value;
			//   return d3.range(0, d.value, step).map(function(value) {
			//     return {value: value, angle: value * k + d.startAngle, pullOutSize: d.pullOutSize};
			//   });
			// }//groupTicks
	
			//http://stackoverflow.com/questions/14446511/what-is-the-most-efficient-method-to-groupby-on-a-javascript-array-of-objects
			var dataGrouper = (function() {
			    var has = function(obj, target) {
			        return _.any(obj, function(value) {
			            return _.isEqual(value, target);
			        });
			    };

			    var keys = function(data, names) {
			        return _.reduce(data, function(memo, item) {
			            var key = _.pick(item, names);
			            if (!has(memo, key)) {
			                memo.push(key);
			            }
			            return memo;
			        }, []);
			    };

			    var group = function(data, names) {
			        var stems = keys(data, names);
			        return _.map(stems, function(stem) {
			            return {
			                key: stem,
			                vals:_.map(_.where(data, stem), function(item) {
			                    return _.omit(item, names);
			                })
			            };
			        });
			    };

			    group.register = function(name, converter) {
			        return group[name] = function(data, names) {
			            return _.map(group(data, names), converter);
			        };
			    };

			    return group;
			}());

			dataGrouper.register("sum", function(item) {
			    return _.extend({}, item.key, {
					words: _.reduce(item.vals, function(memo, node) {
			        	return memo + node.words;
			    	}, 0)
				});
			});
				
		</script>
	</body>
</html>