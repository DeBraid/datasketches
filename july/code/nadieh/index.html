<!DOCTYPE html>
	<head>
		<meta charset="utf-8">
		<style>

			body {
			  /*font-family: 'Stalemate', cursive;*/
			  font-family: 'Macondo Swash Caps', cursive;
			  font-size: 12px;
			}
			
			.group-tick {
				font-family: 'Open Sans', sans-serif;
				font-size: 8px;
				font-weight: 300;
				fill: #b9b9b9;
			}

			.group-tick line {
			    stroke: #909090;
			    stroke-width: 0.5px;
			}

			.band {
			  	opacity: 0.7;
			}
			
			.inner-label {
				font-size: 14px;
				fill: #232323;
				cursor: default;
			}
			
			.outer-label {
				font-size: 14px;
				fill: #5f5f5f;
				cursor: default;
			}

		</style>
		
		<!-- Google fonts -->
		<link href="https://fonts.googleapis.com/css?family=Macondo+Swash+Caps" rel="stylesheet">
		<!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet"> -->
		
		<!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->
		<script src="../../../plugins/d3.js"></script>
		<script src="../../../plugins/underscore.js"></script>
		
		<!-- Custom "chord" and "ribbon" functions -->
		<script src="helix.js"></script>
		<script src="bands.js"></script>
		
	</head>
	<body>
		<div id="chart"></div>
		
		<script>

			var margin = {left:100, top:90, right:100, bottom:90},
				width = Math.min(window.innerWidth, 1100) - margin.left - margin.right,
			    height = Math.min(window.innerWidth, 900) - margin.top - margin.bottom,
			    innerRadius = Math.min(width, height) * .45,
			    outerRadius = innerRadius * 1.05;
	
			////////////////////////////////////////////////////////////
			////////////////// Set-up Chord parameters /////////////////
			////////////////////////////////////////////////////////////
				
			var pullOutSize = 80;
									
			var helix = helix()
			    .padAngle(0.05)
				.sortSubgroups(sortAlpha)
				.heightInner(28)
				.emptyPerc(0.3)
				.widthOffsetInner(30)
				//.widthOffsetInner(function(d) { return 6 * d.length; })
				.value(function(d) { return d.words; })
				.inner(function(d) { return d.character; })
				.outer(function(d) { return d.location; });
			
			var arc = d3.arc()
			    .innerRadius(innerRadius*1.01)
			    .outerRadius(outerRadius);

			var band = band()
			    .radius(innerRadius)
				.pullout(pullOutSize);

			//var formatValue = d3.formatPrefix(",.0", 1e2);
	
			////////////////////////////////////////////////////////////
			////////////////////// Create SVG //////////////////////////
			////////////////////////////////////////////////////////////
						
			var svg = d3.select("#chart").append("svg")
			    .attr("width", width + margin.left + margin.right)
			    .attr("height", height + margin.top + margin.bottom);
			
			////////////////////////////////////////////////////////////
			///////////////////// Read in data /////////////////////////
			////////////////////////////////////////////////////////////
						
			d3.csv('../../data/nadieh/lotr_words_locations.csv', function (error, data) {
	
				////////////////////////////////////////////////////////////
				///////////////////// Prepare the data /////////////////////
				////////////////////////////////////////////////////////////
							
				data.forEach(function(d) {
					d.words = +d.words;
				});
				
				//Only keep the members of the fellowship & remove Voiceover
				var fellowship = ["Frodo","Sam","Pippin","Merry","Gandalf","Aragorn","Boromir","Legolas","Gimli"];
				data = data.filter(function(d) { 
					return fellowship.indexOf(d.character) > -1 && d.location !== "Voiceover"; 
				});	
				
				//Aggregate the data by detailed location
				var dataAgg = dataGrouper.sum(data, ["location","character"]);
				
				//Sort the locations in a particula order
				function sortLocation(a, b) {
					var locationOrder = ["The Shire", "Bree", "Isengard", "Rivendell", "Misty Mountains", "Moria", "Lothlorien", "Parth Galen", "Emyn Muil", "Rohan", "Fangorn", "Gondor", "Mordor"];
				  	return locationOrder.indexOf(a.location) - locationOrder.indexOf(b.location);
				}//sortLocation
				dataAgg.sort(sortLocation);

				////////////////////////////////////////////////////////////
				///////////////////////// Colors ///////////////////////////
				////////////////////////////////////////////////////////////
								
				//Color for the unique locations
				var locations = ["Bree", "Emyn Muil", "Fangorn", "Gondor", "Isengard", "Lothlorien", "Misty Mountains", "Mordor", "Moria", "Parth Galen", "Rivendell", "Rohan", "The Shire"];
				var colors = ["#684F53", "#6B8884", "#324E25", "#C6CAC9", "#213C47", "#628833", "#DDDED9", "#730b0b", "#8a290d", "#306E3F", "#8D9413", "#C99E54", "#3C7E16"];
				var color = d3.scaleOrdinal()
			    	.domain(locations)
			    	.range(colors);
				
				//Create a group that already holds the data
				var g = svg.append("g")
				    .attr("transform", "translate(" + (width/2 + margin.left) + "," + (height/2 + margin.top) + ")")
					.datum(helix(dataAgg));	
	
				////////////////////////////////////////////////////////////
				////////////////////// Draw outer arcs /////////////////////
				////////////////////////////////////////////////////////////

				var arcs = g.append("g")
				    .attr("class", "arcs")
				  .selectAll("g")
				    .data(function(bands) { 
						return bands.groups; 
					})
				  .enter().append("g")
				  	.each(function(d) { 
						d.pullOutSize = (pullOutSize * ( d.startAngle > Math.PI + 1e-2 ? -1 : 1)) 
					})
			 	 	.on("mouseover", fadeArc(.1))
			     	.on("mouseout", fadeArc(0.7));

				var outerArcs = arcs.append("path")
				    .style("fill", function(d) { return color(d.outername); })
				    .attr("d", arc)
					.attr("transform", function(d, i) { //Pull the two slices apart
					  	return "translate(" + d.pullOutSize + ',' + 0 + ")";
					 });

				////////////////////////////////////////////////////////////
				///////////////////// Draw group ticks /////////////////////
				////////////////////////////////////////////////////////////
					 
				 // //Not really an added valye here, so no tick marks
				 // var groupTick = arcs.selectAll(".group-tick")
				 //     .data(function(d) { return groupTicks(d, 5e2); })
				 //   .enter().append("g")
				 //     .attr("class", "group-tick")
				 //     .attr("transform", function(d) { return "translate(" + d.pullOutSize + ',' + 0 + ")rotate(" + (d.angle * 180 / Math.PI - 90) + ") translate(" + outerRadius + ",0)"; });
				 //
				 // groupTick.append("line")
				 //     .attr("x2", 6);
				 //
				 // groupTick
				 //   .filter(function(d) { return d.value % 5e2 === 0; })
				 //   .append("text")
				 //     .attr("x", 8)
				 //     .attr("dy", ".35em")
				 //     .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180) translate(-16)" : null; })
				 //     .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
				 //     .text(function(d) { return d.value; });
					 					
				////////////////////////////////////////////////////////////
				//////////////////// Draw outer labels /////////////////////
				////////////////////////////////////////////////////////////

				//The text needs to be rotated with the offset in the clockwise direction
				var outerLabels = arcs.append("text")
					.each(function(d) { d.angle = ((d.startAngle + d.endAngle) / 2); })
					.attr("dy", ".35em")
					.attr("class", "outer-label")
					.attr("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
					.attr("transform", function(d,i) { 
						var c = arc.centroid(d);
						return "translate(" + (c[0] + d.pullOutSize) + "," + c[1] + ")"
						+ "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
						+ "translate(" + 46 + ",0)"
						+ (d.angle > Math.PI ? "rotate(180)" : "")
					})
					.text(function(d,i){ return d.outername; });

				////////////////////////////////////////////////////////////
				////////////////// Draw inner bands ///////////////////////
				////////////////////////////////////////////////////////////
				
				var bands = g.append("g")
				    .attr("class", "bands")
				  .selectAll("path")
				    .data(function(bands) { 
						return bands; 
					})
				  .enter().append("path")
					.attr("class", "band")
				    .attr("d", band)
				    .style("fill", function(d) { return color(d.outer.outername); });
					
				////////////////////////////////////////////////////////////
				//////////////////// Draw inner labels /////////////////////
				////////////////////////////////////////////////////////////
						
				//The text also needs to be displaced in the horizontal directions
				//And also rotated with the offset in the clockwise direction
				var innerLabels = g.append("g")
					.attr("class","inner-labels")
				  .selectAll("text")
				    .data(function(bands) { 
						return bands.innergroups; 
					})
				  .enter().append("text")
					.attr("class", "inner-label")
					.attr("x", function(d,i) { return d.x; })
					.attr("y", function(d,i) { return d.y; })
					.style("text-anchor", "middle")
					.attr("dy", ".35em")
				    .text(function(d,i) { return d.name; })
			 	 	.on("mouseover", function(d) {
					    d3.selectAll(".band")
					        .filter(function(o) { return o.outer.innername !== d.name; })
					      	.transition()
					        .style("opacity", 0.02);
					})
			     	.on("mouseout", function(d) {
					    d3.selectAll(".band")
					      	.transition()
					        .style("opacity", 0.7);
					});
				  		
			});//d3.csv

			////////////////////////////////////////////////////////////
			///////////////////// Extra functions //////////////////////
			////////////////////////////////////////////////////////////

			//Sort alphabetically
			function sortAlpha(a, b){
				    if(a < b) return -1;
				    if(a > b) return 1;
				    return 0;
			}//sortAlpha
			
			// Returns an event handler for fading a given band group
			function fadeArc(opacity) {
			  return function(g, i) {
			    d3.selectAll(".band")
			        .filter(function(d) { 
						return d.outer.outername !== g.outername; 
					})
			      	.transition()
			        .style("opacity", opacity);
			  };
			}//fadeArc
							
			// // Returns an array of tick angles and values for a given group and step.
			// function groupTicks(d, step) {
			//   var k = (d.endAngle - d.startAngle) / d.value;
			//   return d3.range(0, d.value, step).map(function(value) {
			//     return {value: value, angle: value * k + d.startAngle, pullOutSize: d.pullOutSize};
			//   });
			// }//groupTicks
	
			//http://stackoverflow.com/questions/14446511/what-is-the-most-efficient-method-to-groupby-on-a-javascript-array-of-objects
			var dataGrouper = (function() {
			    var has = function(obj, target) {
			        return _.any(obj, function(value) {
			            return _.isEqual(value, target);
			        });
			    };

			    var keys = function(data, names) {
			        return _.reduce(data, function(memo, item) {
			            var key = _.pick(item, names);
			            if (!has(memo, key)) {
			                memo.push(key);
			            }
			            return memo;
			        }, []);
			    };

			    var group = function(data, names) {
			        var stems = keys(data, names);
			        return _.map(stems, function(stem) {
			            return {
			                key: stem,
			                vals:_.map(_.where(data, stem), function(item) {
			                    return _.omit(item, names);
			                })
			            };
			        });
			    };

			    group.register = function(name, converter) {
			        return group[name] = function(data, names) {
			            return _.map(group(data, names), converter);
			        };
			    };

			    return group;
			}());

			dataGrouper.register("sum", function(item) {
			    return _.extend({}, item.key, {
					words: _.reduce(item.vals, function(memo, node) {
			        	return memo + node.words;
			    	}, 0)
				});
			});
				
		</script>
	</body>
</html>